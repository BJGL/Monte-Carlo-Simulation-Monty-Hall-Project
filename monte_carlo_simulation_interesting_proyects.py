# -*- coding: utf-8 -*-
"""Monte Carlo Simulation: Interesting proyects

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13IEJfz1f2Dlr7JPpR72w0CVpvsGb5_hZ

# **Monty Hall Problem**
"""

import random

def user_input(prompt, default=None):
    """
    Solicita una entrada al usuario permitiendo un valor predeterminado.
    Si el usuario presiona Enter sin escribir nada, se usa el valor 'default'.

    Argumentos:
        prompt (str): El mensaje a mostrar al usuario.
        default (str, opcional): El valor que se usar谩 si la entrada est谩 vac铆a.

    Retorna:
        str: La entrada del usuario o el valor predeterminado.
    """
    # Formateamos el texto para mostrar al usuario la opci贸n por defecto entre corchetes
    prompt_text = '{} [{}]: '.format(prompt, default)
    response = input(prompt_text)

    # Si la respuesta est谩 vac铆a (False) y existe un valor por defecto, retornamos el defecto
    if not response and default:
        return default
    else:
        return response

# ---- Configuraci贸n de la Simulaci贸n ----

# Pedimos al usuario el n煤mero de simulaciones a ejecutar
# Usamos 20,000 como valor por defecto si el usuario solo presiona Enter
try:
    num_runs = int(user_input('Ingrese el n煤mero de ejecuciones', '20000'))
except ValueError:
    print("Entrada no v谩lida. Usando 20000 por defecto.")
    num_runs = 20000

# Inicializamos los contadores para las formas de ganar
first_choice_wins = 0  # Contador de victorias si el jugador SE QUEDA con su puerta
pick_change_wins = 0   # Contador de victorias si el jugador CAMBIA de puerta
doors = ['a', 'b', 'c'] # Lista de las tres puertas posibles

# Inicializamos listas para almacenar resultados individuales (煤til para gr谩ficos futuros)
results_stay = []
results_switch = []

print(f"\n--- Iniciando Simulaci贸n Monte Carlo ({num_runs} partidas) ---\n")

# ---- Ejecuci贸n del M茅todo Monte Carlo ----
for i in range(num_runs):
    # 1. El programa elige aleatoriamente d贸nde est谩 el premio (winner)
    winner = random.choice(doors)

    # 2. El "jugador" elige aleatoriamente una puerta (pick)
    pick = random.choice(doors)

    # 3. Evaluamos las estrategias:
    if pick == winner:
        # CASO 1: El jugador eligi贸 la puerta correcta desde el principio.
        # - Si se QUEDA: Gana.
        # - Si CAMBIA: Pierde (porque cambiar铆a a una puerta con cabra).
        first_choice_wins += 1
        results_stay.append(1)     # 1 = Gan贸
        results_switch.append(0)   # 0 = Perdi贸
    else:
        # CASO 2: El jugador eligi贸 una puerta incorrecta (Cabra).
        # El anfitri贸n (que sabe d贸nde est谩 el premio) abre la otra puerta con cabra.
        # Por lo tanto, la 煤nica puerta cerrada que queda es la del PREMIO.
        # - Si se QUEDA: Pierde.
        # - Si CAMBIA: Gana autom谩ticamente.
        pick_change_wins += 1
        results_stay.append(0)     # 0 = Perdi贸
        results_switch.append(1)   # 1 = Gan贸

# ---- Mostrar Resultados ----
print('Resultados Finales:')
print('=' * 30)
print('Victorias manteniendo la elecci贸n original (Quedarse) = {}'.format(first_choice_wins))
print('Victorias cambiando de elecci贸n (Cambiar)             = {}'.format(pick_change_wins))
print('-' * 30)

# Calculamos y mostramos los porcentajes (usando :.2% para formato de porcentaje)
prob_stay = first_choice_wins / num_runs
prob_switch = pick_change_wins / num_runs

print('Probabilidad de ganar con la elecci贸n inicial: {:.2%} (aprox 33.33%)'.format(prob_stay))
print('Probabilidad de ganar cambiando de puerta:     {:.2%} (aprox 66.66%)'.format(prob_switch))

# Pausa final para que el usuario pueda leer los resultados antes de cerrar
input('\nPresione la tecla Enter para salir.')

"""# **Game Version**"""

import tkinter as tk
from tkinter import ttk, messagebox
import random
import os

class ModernGame(tk.Tk):
    """
    Clase principal de la aplicaci贸n.
    Implementa una versi贸n moderna y estilizada del juego Monty Hall
    utilizando la librer铆a Tkinter para la interfaz gr谩fica.
    Incluye un modo de juego manual y una simulaci贸n de Monte Carlo.
    """

    # --- CONFIGURACIN ---
    # Ruta base donde se encuentran las im谩genes del juego.
    BASE_PATH = r"C:\Users\HP\Downloads\MonteCarlo"

    # Paleta de Colores (Tema visual "Flat Dark")
    COLOR_BG = "#2C3E50"        # Fondo principal (Azul oscuro gris谩ceo)
    COLOR_PANEL = "#34495E"     # Paneles laterales (Un poco m谩s claro)
    COLOR_TEXT = "#ECF0F1"      # Texto claro (Blanco hueso)
    COLOR_ACCENT = "#E67E22"    # Naranja para acciones principales
    COLOR_SUCCESS = "#27AE60"   # Verde para mensajes de 茅xito/ganar
    COLOR_DANGER = "#C0392B"    # Rojo para mensajes de error/perder
    COLOR_BTN = "#2980B9"       # Azul para los botones de las puertas

    # Tupla con los identificadores de las tres puertas
    doors = ('a', 'b', 'c')

    def __init__(self):
        """
        Constructor de la clase. Inicializa la ventana principal,
        configura las variables de estado y construye la interfaz.
        """
        super().__init__()

        # Configuraci贸n b谩sica de la ventana
        self.title("Monty Hall | Edici贸n Definitiva")
        self.geometry("1000x750")
        self.configure(bg=self.COLOR_BG)

        # --- Variables de estado del juego ---
        # Ruta de la imagen actual a mostrar
        self.img_file = os.path.join(self.BASE_PATH, 'all_closed.png')
        self.choice = ''       # Puerta elegida por el jugador
        self.winner = ''       # Puerta que tiene el premio
        self.reveal = ''       # Puerta que revela el anfitri贸n (cabra)
        self.game_over = False # Bandera de estado del juego

        # --- Estad铆sticas ---
        # Diccionario para llevar el conteo de victorias y juegos totales
        self.stats = {
            'stay_wins': 0,     # Victorias al quedarse
            'stay_total': 0,    # Total de juegos qued谩ndose
            'switch_wins': 0,   # Victorias al cambiar
            'switch_total': 0   # Total de juegos cambiando
        }

        # Inicializaci贸n de estilos y widgets
        self.setup_styles()     # Configura colores y fuentes
        self.create_widgets()   # Crea los elementos visuales
        self.update_image()     # Carga la primera imagen

    def setup_styles(self):
        """
        Configura el aspecto visual (Look & Feel) de los widgets utilizando ttk.Style.
        Define colores personalizados para botones, etiquetas y marcos.
        """
        style = ttk.Style()
        # 'clam' es un tema vers谩til que permite mayor personalizaci贸n de colores
        style.theme_use('clam')

        # Estilo para Botones Generales (Simulaci贸n, Reset, etc.)
        style.configure('TButton', font=('Segoe UI', 11, 'bold'), borderwidth=0, focuscolor='none')
        # Cambiar color cuando el mouse pasa por encima (hover)
        style.map('TButton', background=[('active', self.COLOR_ACCENT)])

        # Estilo Espec铆fico para los Botones de las Puertas (M谩s grandes y azules)
        style.configure('Door.TButton', font=('Segoe UI', 14, 'bold'), background=self.COLOR_BTN, foreground='white')

        # Estilo para Etiquetas (Labels) de texto
        style.configure('TLabel', background=self.COLOR_PANEL, foreground=self.COLOR_TEXT, font=('Segoe UI', 11))

        # Estilo para Contenedores (Frames)
        style.configure('TFrame', background=self.COLOR_BG)
        style.configure('Panel.TFrame', background=self.COLOR_PANEL, relief='flat')

    def create_widgets(self):
        """
        Construye y posiciona todos los elementos de la interfaz gr谩fica (GUI):
        Encabezado, 谩rea de juego, paneles de control y barra lateral de estad铆sticas.
        """
        # --- 1. ENCABEZADO SUPERIOR ---
        header_frame = tk.Frame(self, bg=self.COLOR_PANEL, height=60)
        header_frame.pack(fill='x', side='top')

        title = tk.Label(header_frame, text="EL PROBLEMA DE MONTY HALL",
                         font=('Segoe UI Black', 24), bg=self.COLOR_PANEL, fg=self.COLOR_ACCENT)
        title.pack(pady=10)

        # --- 2. CONTENEDOR PRINCIPAL ---
        main_container = tk.Frame(self, bg=self.COLOR_BG)
        main_container.pack(fill='both', expand=True, padx=20, pady=20)

        # === SECCIN IZQUIERDA: REA DE JUEGO ===
        game_area = tk.Frame(main_container, bg=self.COLOR_BG)
        game_area.pack(side='left', fill='both', expand=True, padx=(0, 10))

        # A) Marco para la imagen del juego
        self.img_frame = tk.Frame(game_area, bg='white', bd=5)
        self.img_frame.pack(pady=10)

        self.photo_lbl = tk.Label(self.img_frame, bg='black')
        self.photo_lbl.pack()

        # B) Panel de Estado (Texto narrativo)
        self.status_lbl = tk.Label(game_area, text="Bienvenido. 隆Elige una puerta para comenzar!",
                                   font=('Segoe UI', 14, 'italic'), bg=self.COLOR_BG, fg=self.COLOR_ACCENT)
        self.status_lbl.pack(pady=15)

        # C) Controles Iniciales (Botones de Puertas A, B, C)
        self.controls_frame = tk.Frame(game_area, bg=self.COLOR_BG)
        self.controls_frame.pack(pady=10)

        tk.Label(self.controls_frame, text="TU ELECCIN:", bg=self.COLOR_BG, fg='white', font=('Segoe UI', 10, 'bold')).pack(pady=5)

        btn_frame = tk.Frame(self.controls_frame, bg=self.COLOR_BG)
        btn_frame.pack()

        # Botones de selecci贸n de puerta
        self.btn_a = ttk.Button(btn_frame, text="Puerta A", style='Door.TButton', command=lambda: self.select_door('a'))
        self.btn_b = ttk.Button(btn_frame, text="Puerta B", style='Door.TButton', command=lambda: self.select_door('b'))
        self.btn_c = ttk.Button(btn_frame, text="Puerta C", style='Door.TButton', command=lambda: self.select_door('c'))

        self.btn_a.grid(row=0, column=0, padx=10, ipady=10, ipadx=10)
        self.btn_b.grid(row=0, column=1, padx=10, ipady=10, ipadx=10)
        self.btn_c.grid(row=0, column=2, padx=10, ipady=10, ipadx=10)

        # D) Controles de Decisi贸n Final (Ocultos al inicio)
        # Se muestran despu茅s de que el anfitri贸n abre una puerta
        self.decision_frame = tk.Frame(game_area, bg=self.COLOR_BG)

        lbl_dec = tk.Label(self.decision_frame, text="驴Quieres CAMBIAR de puerta?",
                           bg=self.COLOR_BG, fg=self.COLOR_TEXT, font=('Segoe UI', 16, 'bold'))
        lbl_dec.pack(pady=5)

        dec_btn_frame = tk.Frame(self.decision_frame, bg=self.COLOR_BG)
        dec_btn_frame.pack()

        self.btn_switch = tk.Button(dec_btn_frame, text="S, CAMBIAR", bg=self.COLOR_ACCENT, fg='white',
                                    font=('Segoe UI', 12, 'bold'), width=15, command=lambda: self.finalize_game(True))
        self.btn_stay = tk.Button(dec_btn_frame, text="NO, QUEDARME", bg="#7F8C8D", fg='white',
                                  font=('Segoe UI', 12, 'bold'), width=15, command=lambda: self.finalize_game(False))

        self.btn_switch.grid(row=0, column=0, padx=10)
        self.btn_stay.grid(row=0, column=1, padx=10)


        # === SECCIN DERECHA: BARRA LATERAL DE ESTADSTICAS ===
        sidebar = ttk.Frame(main_container, style='Panel.TFrame', padding=15)
        sidebar.pack(side='right', fill='y', padx=(10, 0))

        # T铆tulo de la secci贸n
        tk.Label(sidebar, text="ESTADSTICAS", font=('Segoe UI', 14, 'bold', 'underline'),
                 bg=self.COLOR_PANEL, fg='white').pack(pady=(0, 15))

        # Grid (Tabla) de Estad铆sticas
        stats_grid = tk.Frame(sidebar, bg=self.COLOR_PANEL)
        stats_grid.pack(fill='x')

        # Fila 1: Estad铆sticas de "Al Quedarse"
        tk.Label(stats_grid, text="AL QUEDARSE:", bg=self.COLOR_PANEL, fg="#BDC3C7").grid(row=0, column=0, sticky='w')
        self.lbl_stay_pct = tk.Label(stats_grid, text="0.0%", font=('Consolas', 20, 'bold'), bg=self.COLOR_PANEL, fg=self.COLOR_DANGER)
        self.lbl_stay_pct.grid(row=1, column=0, pady=5)
        self.lbl_stay_count = tk.Label(stats_grid, text="0/0 ganados", bg=self.COLOR_PANEL, fg="white")
        self.lbl_stay_count.grid(row=2, column=0, pady=(0, 15))

        # Fila 2: Estad铆sticas de "Al Cambiar"
        tk.Label(stats_grid, text="AL CAMBIAR:", bg=self.COLOR_PANEL, fg="#BDC3C7").grid(row=3, column=0, sticky='w')
        self.lbl_switch_pct = tk.Label(stats_grid, text="0.0%", font=('Consolas', 20, 'bold'), bg=self.COLOR_PANEL, fg=self.COLOR_SUCCESS)
        self.lbl_switch_pct.grid(row=4, column=0, pady=5)
        self.lbl_switch_count = tk.Label(stats_grid, text="0/0 ganados", bg=self.COLOR_PANEL, fg="white")
        self.lbl_switch_count.grid(row=5, column=0, pady=(0, 20))

        # Separador visual
        ttk.Separator(sidebar, orient='horizontal').pack(fill='x', pady=10)

        # Secci贸n de Simulaci贸n
        tk.Label(sidebar, text="SIMULACIN RPIDA", font=('Segoe UI', 12, 'bold'),
                 bg=self.COLOR_PANEL, fg='white').pack(pady=10)

        tk.Label(sidebar, text="Simula juegos autom谩ticos para ver probabilidades reales.",
                 bg=self.COLOR_PANEL, fg="#BDC3C7", wraplength=150, justify='center').pack(pady=5)

        ttk.Button(sidebar, text="Simular 100 Juegos", command=lambda: self.run_simulation(100)).pack(pady=5, fill='x')
        ttk.Button(sidebar, text="Simular 1,000 Juegos", command=lambda: self.run_simulation(1000)).pack(pady=5, fill='x')

        # Separador y Botones de Control de Juego
        ttk.Separator(sidebar, orient='horizontal').pack(fill='x', pady=10)
        ttk.Button(sidebar, text=" Jugar T煤 (Reiniciar Ronda)", command=self.reset_game).pack(pady=5, fill='x')
        ttk.Button(sidebar, text="Reiniciar Todo (Stats)", command=self.reset_stats).pack(pady=5, fill='x')

        # Bot贸n Siguiente Ronda (visible solo al final del juego)
        self.btn_next = tk.Button(sidebar, text="SIGUIENTE RONDA >>", bg=self.COLOR_SUCCESS, fg='white',
                                  font=('Segoe UI', 12, 'bold'), command=self.reset_game, state='disabled')
        self.btn_next.pack(side='bottom', fill='x', pady=10)


    # --- LGICA DEL JUEGO ---

    def update_image(self):
        """
        Maneja la carga, redimensionado y actualizaci贸n de la imagen en pantalla.
        Intenta cargar la imagen desde la ruta definida en self.img_file.
        """
        if os.path.exists(self.img_file):
            try:
                full_img = tk.PhotoImage(file=self.img_file)
                # subsample(2, 2) reduce la imagen a la mitad (1 p铆xel de cada 2)
                self.img_reduced = full_img.subsample(2, 2)
                self.photo_lbl.configure(image=self.img_reduced)
                # Es crucial guardar una referencia (.image) para evitar que el recolector de basura la borre
                self.photo_lbl.image = self.img_reduced
            except Exception as e:
                self.status_lbl.config(text=f"Error cargando imagen: {e}")
        else:
            self.status_lbl.config(text=f"Falta archivo: {os.path.basename(self.img_file)}")

    def select_door(self, door):
        """
        Paso 1 del Juego: El jugador selecciona una puerta inicial.

        Argumentos:
            door (str): Identificador de la puerta ('a', 'b' o 'c').
        """
        self.choice = door
        self.status_lbl.config(text=f"Has elegido la Puerta {door.upper()}. El anfitri贸n va a abrir otra puerta...")

        # Desactivamos los botones para evitar que el usuario cambie antes de tiempo
        for btn in [self.btn_a, self.btn_b, self.btn_c]:
            btn.state(['disabled'])

        # L贸gica Monty Hall: Determinamos d贸nde est谩 el premio aleatoriamente
        self.winner = random.choice(self.doors)

        # El anfitri贸n debe revelar una puerta que NO sea la del jugador Y que tenga una cabra (no el ganador)
        remaining = [d for d in self.doors if d != self.winner and d != self.choice]
        self.reveal = random.choice(remaining)

        # Usamos .after() para crear una peque帽a pausa dram谩tica antes de revelar la cabra
        self.after(600, self.perform_reveal)

    def perform_reveal(self):
        """
        Paso 2 del Juego: El anfitri贸n abre una puerta con cabra.
        """
        # Actualizamos la imagen para mostrar la puerta revelada
        self.img_file = os.path.join(self.BASE_PATH, f'reveal_{self.reveal}.jpeg')
        self.update_image()

        self.status_lbl.config(text=f"隆La Puerta {self.reveal.upper()} tiene una CABRA! 驴Quieres cambiar tu elecci贸n?")

        # Ocultamos los botones de selecci贸n inicial (A, B, C)
        self.controls_frame.pack_forget()
        # Mostramos los botones de decisi贸n (Cambiar / Quedarse)
        self.decision_frame.pack(pady=10)

    def finalize_game(self, switch):
        """
        Paso 3 del Juego: Resoluci贸n final.
        Calcula si el jugador gan贸 o perdi贸 bas谩ndose en si decidi贸 cambiar o no.

        Argumentos:
            switch (bool): True si el jugador cambi贸 de puerta, False si se qued贸.
        """
        door_list = list(self.doors)
        is_win = False

        final_pick = self.choice

        if switch:
            # L贸gica AL CAMBIAR:
            # La nueva elecci贸n es la puerta que no es la original ni la revelada
            final_pick = [d for d in door_list if d != self.choice and d != self.reveal][0]
            self.stats['switch_total'] += 1
            if final_pick == self.winner:
                self.stats['switch_wins'] += 1
                is_win = True
        else:
            # L贸gica AL QUEDARSE:
            # Mantenemos la elecci贸n original
            self.stats['stay_total'] += 1
            if self.choice == self.winner:
                self.stats['stay_wins'] += 1
                is_win = True

        # Actualizamos la interfaz con el resultado
        if is_win:
            self.img_file = os.path.join(self.BASE_PATH, f'money_{final_pick}.png')
            msg = "隆FELICIDADES! 隆GANASTE EL DINERO! "
            self.status_lbl.config(text=msg, fg=self.COLOR_SUCCESS)
        else:
            self.img_file = os.path.join(self.BASE_PATH, f'goat_{final_pick}.png')
            msg = "隆Oh no! Es una cabra. "
            self.status_lbl.config(text=msg, fg=self.COLOR_DANGER)

        self.update_image()
        self.update_stats_display()

        # Preparamos la interfaz para finalizar
        self.decision_frame.pack_forget() # Ocultamos botones de decisi贸n
        self.btn_next.config(state='normal', bg=self.COLOR_ACCENT) # Activamos bot贸n de "Siguiente"

    def reset_game(self):
        """
        Reinicia el tablero y las variables para comenzar una nueva ronda
        sin borrar las estad铆sticas acumuladas.
        """
        self.img_file = os.path.join(self.BASE_PATH, 'all_closed.png')
        self.update_image()

        self.status_lbl.config(text="Nueva ronda. 隆Elige una puerta!", fg=self.COLOR_ACCENT)
        self.btn_next.config(state='disabled', bg=self.COLOR_SUCCESS)

        # Restaurar interfaz inicial
        self.controls_frame.pack(pady=10)
        self.decision_frame.pack_forget() # Asegurar que botones finales est茅n ocultos

        # Reactivar botones de puertas
        for btn in [self.btn_a, self.btn_b, self.btn_c]:
            btn.state(['!disabled'])

    # --- LGICA DE ESTADSTICAS Y SIMULACIN ---

    def update_stats_display(self):
        """
        Calcula los porcentajes de victoria y actualiza las etiquetas
        en la barra lateral.
        """
        # Calcular estad铆sticas de "Quedarse"
        s_wins = self.stats['stay_wins']
        s_total = self.stats['stay_total']
        # Evitar divisi贸n por cero
        s_pct = (s_wins / s_total * 100) if s_total > 0 else 0

        self.lbl_stay_pct.config(text=f"{s_pct:.1f}%")
        self.lbl_stay_count.config(text=f"{s_wins}/{s_total}")

        # Calcular estad铆sticas de "Cambiar"
        sw_wins = self.stats['switch_wins']
        sw_total = self.stats['switch_total']
        sw_pct = (sw_wins / sw_total * 100) if sw_total > 0 else 0

        self.lbl_switch_pct.config(text=f"{sw_pct:.1f}%")
        self.lbl_switch_count.config(text=f"{sw_wins}/{sw_total}")

    def reset_stats(self):
        """Reinicia los contadores de estad铆sticas a cero."""
        self.stats = {'stay_wins': 0, 'stay_total': 0, 'switch_wins': 0, 'switch_total': 0}
        self.update_stats_display()
        self.reset_game()

    def run_simulation(self, runs):
        """
        Ejecuta N juegos autom谩ticamente a alta velocidad (M茅todo Monte Carlo).
        La estrategia en la simulaci贸n es aleatoria (50% cambiar, 50% quedarse)
        para poblar ambas estad铆sticas y mostrar la convergencia de probabilidades.

        Argumentos:
            runs (int): N煤mero de juegos a simular (ej. 100, 1000).
        """
        self.status_lbl.config(text=f"Simulando {runs} juegos...", fg="white")
        self.update() # Forzar actualizaci贸n de UI antes de congelar brevemente el hilo

        for _ in range(runs):
            winner = random.choice(self.doors)
            choice = random.choice(self.doors)

            # El anfitri贸n revela una cabra
            remaining = [d for d in self.doors if d != winner and d != choice]
            reveal = random.choice(remaining)

            # Decidimos aleatoriamente si simulamos un "Cambio" o "Quedarse"
            switch = random.choice([True, False])

            if switch:
                # Si cambiamos, elegimos la puerta restante
                new_pick = [d for d in self.doors if d != choice and d != reveal][0]
                self.stats['switch_total'] += 1
                if new_pick == winner:
                    self.stats['switch_wins'] += 1
            else:
                # Si nos quedamos, mantenemos choice
                self.stats['stay_total'] += 1
                if choice == winner:
                    self.stats['stay_wins'] += 1

        self.update_stats_display()
        self.status_lbl.config(text=f"隆Simulaci贸n de {runs} juegos completada!", fg=self.COLOR_SUCCESS)

# Punto de entrada principal
if __name__ == "__main__":
    app = ModernGame()
    app.mainloop()